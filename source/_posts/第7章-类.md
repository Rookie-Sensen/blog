---
title: 第7章|类
date: 2023-06-02 21:41:41
tags: c++primer
---

# 7. 类

## 7.1 定义抽象数据类型

### 7.1.2 定义类

成员函数的**声明**必须在类的内部，它的定义则既可以在类的内部也可以在外部。**作为借口组成部分的非成员函数，例如`add`,`read`和`print`（执行操作的部分），他们的定义和声明都在类的外部。**

**定义在类内部的函数是隐式的`inline`函数。**（因此，大多数时候都是把成员函数定义在类的外部。）

#### 引入`const`成员函数

`std::string isbn() const { return this->bookNo; }`

这里，`const`的作用是修改隐式`this`指针的类型。

一般情况下，`this`指针是一个常量指针，即不能指向其他的对象。因为要时时刻刻指向当前对象，否则就没有意义了。**同时，如果此时的对象他是一个常量，那么用一个不是指向常量的指针（普通`this`）指向了常量，肯定会发生错误。** 但是`this`指针是隐式定义的（我们找不到在哪定义的），解决办法就是在函数参数列表后面加一个`const`，表示`this`指针指向的是常量。

如此一来，就不能在此成员函数里面（通过`this`指针）改变成员变量了，即为常量成员函数。

### 7.1.3 定义类相关的非成员函数

类的作者常常需要定义一些辅助函数，比如`add`,`read`,和`print`等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类的本身。

因此我们定义这类函数，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则他一般应与声明在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。

**一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。**

### 7.1.4 构造函数

构造函数的名字与类名相同，且没有返回值类型。

**构造函数不能被声明成`const`的。**

**当我们创建类的一个`const`对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性。因此构造函数在`const`对象的构造过程中可以向其写值。**

#### 合成的默认构造函数

如果类中没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数，又称为**合成的默认构造函数**。

* 如果存在类内初始值，用它来初始化成员。
* 否则，默认初始化该成员。

#### 某些类不能依赖于合成的默认构造函数

只有当类没有声明任何构造函数时，编译器才会自动的生成默认构造函数。

**如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。**（因为，内置类型和复合类型，如数组和指针，如果被默认初始化，则其值将是未定义的。）

如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。

#### `= default`的含义

`Sales_data() = default;`表示这是一个默认构造函数。

在c++11中，如果需要默认的行为，可以通过在参数列表后面写上`= default`来要求编译器生成构造函数。其既可以和声明一起出现在类的内部，也作为定义出现在外部。

#### 构造函数初始值列表

形如：

```c++
Sales_data(const string& s): bookNo(s) { } // 将s的值赋给bookNo（成员变量）
Sales_data(const string& s, unsigned n, double p)://同上
		   bookNo(s), units_sold(n), revenue(p * n) { }
```

在冒号后直到花括号之前的部分称为**构造函数初始值列表**，他负责为新创建的对象的一个或几个数据成员赋初值。

### 7.1.5 拷贝、赋值和析构

如果我们不主动定义这些操作，则编译器将替我们合成它们。 编译器合成的版本会对对象的每个成员进行拷贝、赋值和销毁操作。

#### 某些类不能依赖于合成的版本

当类需要分配类对象之外的资源时，合成的版本常常会失效。

如果类包含`vector`或者`string`成员，则其拷贝、赋值和销毁的合成版本能够正常工作。当我们对含有`vector`成员的对象执行拷贝或者赋值操作时，`vector`类会设法拷贝或者赋值成员中的元素。当这样的对象销毁时，将销毁`vector`对象，也就是一次销毁其中的每一个元素。

## 7.2 访问控制与封装

* 定义在`public`说明符之后的成员在整个程序内可被访问，`public`成员定义类的接口。
* 定义在`private`说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，`private`部分封装了类的实现细节。

#### 使用`class`或`struct`关键字

`class`和`struct`的区别：`class`在第一个访问说明符之前定义的成员默认是`private`,而`struct`是`public`的。

### 7.2.1 友元

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元**，只需要增加一条以`friend`关键字开始的函数声明语句即可。

```c++
friend istream& read(istream&, Sales_data&);
```

友元声明只能出现在类的内部，具体位置不限，**一般来说最好在类定义开始或结束前的位置集中声明友元。**

#### 友元的声明

友元的声明仅仅只是指定了访问权限（不是通常意义上的函数声明）。也就意味着，如果想直接从类中调用友元函数，必须在友元声明之外再专门对函数进行一次声明。

通常把友元的声明（真正意义上的声明）与类本身放置再同一个头文件中。

## 7.3 类的其他特性

### 7.3.1 类成员再探

#### 定义一个类型成员

所谓类型成员，就是在类的内部对一个类型进行重命名。

```c++
class Screen {
    public:
    	typedef std::string::size_type pos;
}
```

上面代码中，`pos`就是一个类型成员，他是`std::string::size_type`的别名，当然这个名字只在类内有效。

`using pos = std::string::size_type;`也可以。

与普通的的成员的区别在于，**类型成员必须先定义后使用。**

#### 令成员作为内联函数

* 直接在类内定义函数，此时的成员函数会被编译器隐式的默认为内联函数。

* 在类的内部把`inline`作为声明的一部分显式的声明成员函数。

  ```c++
  class Screen {
      public:
      	inline char get(pos ht, pos wd) const;
  }
  ```

* 在类的外部用`inline`关键字修饰函数的定义。

  ```c++
  class Screen {
      public:
      	Screen& move(pos r, pos c); //此时还不是内联，等外部定义
  }
  inline   //外部定义时用inline修饰，他也是内联成员函数
  Screen& move(pos r, pos c) {
      /*...*/
  }
  ```

  **最好只在类外部定义的地方说明`inline`，方便理解。**

#### 重载成员函数

成员函数也可以重载，和普通函数重载方式一样。

#### 可变数据成员

有时后会希望能改变成员变量的值，即便是用`const`成员函数调用时，也能够修改。比如说，我们要统计程序调用了该`const`函数多少次。

```c++
class Screen {
    public:
    	void some_memver() const { ++access_ctr }
    private:
    	mutable size_t access_ctr;//用来记录调用了多少次
}
```

以上函数，如果不使用`mutable`来修饰变量，那么这个`const`成员函数就会报错，因为其修改了类的值。

一个可变数据成员永远不会是`const`，因为添加了`mutable`之后，他就一定能够被改变，即使他是一个`const`对象的成员。

#### 类数据成员的初始值

当我们提供一个类内初始值时，必须以符号`=`或者花括号表示。

```c++
class Window_mgr {
private:
    vector<Screen> screens{Screen(21, 80, ' ')};
}
```

上述代码，就是用了一个花括号来初始成员变量`screens`。即当对象定义时，没有给此对象的`screens`初始化的话，编译器就会将花括号的内容用来默认初始化这个`screens`。

### 7.3.2 返回*this的成员函数

函数体的返回值类型要是类型的引用，此时`return *this;`返回的就是这个对象的本身，否则只是返回的一个拷贝。 

#### 从`const`成员函数返回`*this`

**一个`const`成员函数如果以引用的形式返回`*this`，那么它的返回类型将是常量引用。**

但是有时候我们不希望其是常量引用。书中举了个例子，当我们要定义一个显示字符内容的函数`display()`时，由于显示字符不需要更改对象的内容，因此将其定义为常量成员函数。但是却希望`display()`函数能与`move()`,`set()`等函数一起实现链式编程，这就要求`display()`函数要返回`*this`的引用。但根据上面的规律，返回的是一个常量引用，就不能再对其调用`move()`等会改变对象的值的函数了。

解决方法：

#### 基于`const`的重载

通过`const`会区分两个函数这一性质（非`const`的对象不会调用`const`成员函数，会去调用普通的），在类内定义`display()`的重载，一个用于调用常量对象用于显示字符内容。一个用来实现与`move()`等函数的链式编程。

### 7.3.3 类类型

每个类定义了唯一的类型。如果有两个类，它们所有的成员都一样，它们依然是两个不同的类。

#### 类的声明

```c++
class Screen;
```

如此，我们仅仅声明了`Screen`类，却没有定义它。也被称为**前向声明**。

一旦一个类的名字出现后，他就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针。**但是只有类被定义后，编译器才知道这个类在内存中占用多大的位置，因此类中的成员类型不能是类本身。**

### 7.3.4 友元再探

除了可以将非成员函数定义为友元，也可以将类定义为友元。此外，友元函数可以定义再类的内部，此时其是内联的。

#### 类之间的友元关系

如果通过一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

**注意：友元关系不存在传递性。即，一个类的其中一个友元类，不能访问这个类中的另一个友元类中的私有成员。**

#### 令成员函数作为友元

有时后，只想让其他类中的某个成员函数可以访问类的私有成员，而不希望该类所有成员函数都可以访问。就可以只将该成员函数指定为友元。

此时，我们必须指出该友元函数属于哪一个类。

```c++
class Screen {
    //注意，window_mgr这个类需要在Screen这个类之前被声明
    friend void Window_mgr::clear(ScreenIndex);
};
```

上述代码中`clear()`就是属于`Window_mgr`这个类的成员函数，指定为了`Screen`类的友元。

规则：

* 需要首先定义`Window_mgr`类，其中声明`clear()`函数，但是不能定义它。在`clear()`使用`Screen`的成员之前必须先声明Screen。
* 接下来定义`Screen`，包括对于`clear`的友元声明。
* 最后定义`clear`,此时它才可以使用`Screen`的成员。

#### 函数重载和友元

虽然函数重载之间名字相同，但是它们还是属于不同的函数。因此如果想要对所有重载的函数都声明为友元，就要一个一个不漏的全部声明为友元。

#### 友元声明和作用域

友元声明只是单纯的影响了友元的访问权限，它并不算一个真正的声明。

因此在其他函数使用这个友元函数时，一定需要在之前有一个真正的对该友元函数的声明，才不会报错。

## 7.4 类的作用域

在类外访问类类型的成员，用`::`。

```c++
Screen::pos ht = 24, wd = 80; //pos是在Screen内部定义的类类型
```

#### 作用域和定义在类外部的成员

形如：

```c++
void Window_mgr::clear(ScreenIndex i) {
    Screen& s = screens[i];
    s.contents = string(s.height * s.width, ' ');
}
```

上述代码，`clear`函数前添加了`window_mgr`，因此，该函数可以访问到`Window_mgr`类中的所有类型。包括其参数列表中`ScreenIndex`是在`Window_mgr`中定义的，函数体内部的`screens`也是在`Window_mgr`类中定义的。

特别的是，返回值类型是在`Window_mgr::`之前。也就是说返回值类型并不能使用`Window_mgr`中定义的一些东西。

如果返回值会返回类内部定义的成员，比如类类型。就需要在返回值类型前也加上作用域。

如：

```c++
Window_mgr::ScreenIndex
Window_mgr::addScreen(const Screen& s) {
    screens.push_back(s);
    return screens.size() - 1;
}
```

## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

用构造函数初始值列表来初始化对象，效率比在构造函数内部依次赋值要高。

#### 构造函数的初始值有时必不可少

**如果成员是`const`、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。**

#### 成员初始化的顺序

使用构造函数初始值列表来初始化对象时，其成员变量的初始化顺序时按照成员变量在类中的定义顺序来觉得的，而不是根据初始值列表的出现顺序决定。

### 7.5.2 委托构造函数

所谓委托构造函数，就是在构造函数的初始化列表中，使用其他的构造函数来对所有的成员变量赋值。

```c++
class Sales_data {
public:
    //普通构造函数
    Sales_data(std::string s, unsigned cnt, double price) :
    	bookNo(s), units_sold(cnt), revenue(cnt*price) { }
    //以下构造函数，将初始化工作委托给了其他的构造函数
    Sales_data(): Sales_data("", 0, 0) { }//委托给了第一个
    Sales_data(std::string s): Sales_data(s, 0, 0) { }//委托给了第一个
    Sales_data(std::istream& is): Sales_data() { read(is, *this) }//委托给了第二个
}
```

### 7.5.3 默认构造函数的作用

默认构造函数可以防止，如果类中有其他类的成员变量时，如果被包含的类没有默认构造函数，那么在对当前类进行默认初始化时会出错。因为编译器不能默认初始化那个没有默认构造函数的成员变量。

**在实际中，如果定义了其他的构造函数，那么最好也提供一个默认构造函数。**

#### 使用默认构造函数

```c++
Sales_data obj(); //错！，这其实是声明了一个返回值类型为Sales_data的函数
Sales_data obj1;  //这个才是正确的
```

**使用默认构造函数，不要在变量名后面带括号。**

### 7.5.4 隐式的类类型转换

构造函数只接受一个实参，则它实际上定义了转换为此类型的隐式转换机制，这种构造函数成为**转换构造函数**。

```c++
string null_book = "9-999-99999-9";
item.combine(null_book); //item是一个Sales_data对象
```

一般来说，combine成员函数是应该接受一个`Sales_data`类型的对象的，但是这里只接受了一个`string`对象。这是因为在`Sales_data`内部定义了一个接受`string`类型的构造函数，此时就会调用这个构造函数来根据此`string`自动创建一个`Sales_data`对象。

#### 只允许一步类类型转换

类型转换中，编译器只会进行一步。

```c++
item.combine("9-999-99999-9");
```

这个就会报错了，他先将字符串隐式的转化成`string`类型（第一步），再想将`string`转化为`Sales_data`（第二步），这就是错误的。

#### 抑制构造函数定义的隐式转换（`explicit`）

有时候，不想让只有一个参数的构造函数成为隐式类型转换的转换构造函数，就可以在函数声明前加上`explicit`。

```c++
//一下语句出现再类的内部
explicit Sales_data(const string& s) : bookNo(s) { }
```

此时语句`item.combine(null_book);`将会报错，因为该构造函数已经不支持类型转换。

#### `explicit`构造函数只能用于直接初始化

因为隐式转化有一种情况就是用`=`号来触发，因此`explicit`构造函数只能用来直接初始化（括号），而不能用赋值号进行。

### 7.5.5 聚合类

* 所有成员都是`public`的
* 没有定义任何构造函数
* 没有类内初始值
* 没有基类，也没有`virtual`函数

满足上面4个条件的类才叫聚合类。并且聚合类有特殊的初始化语法形式，即花括号。

```c++
Data val1 = { 0, "Anna" };
```

初始值的顺序必须与声明的顺序一致，即第一个成员的初始值要放在第一个，然后是第二个，以此类推。

### 7.5.6 字面值常量类

所有数据成员都是字面值类型的
