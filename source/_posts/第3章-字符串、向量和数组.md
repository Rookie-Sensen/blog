---
title: 第3章|字符串、向量和数组
date: 2023-06-02 21:37:31
tags: c++primer
---

# 3.字符串、向量和数组

## 3.1 命名空间的using声明

#### 头文件不应包含using声明

因为头文件会拷贝到所有引用了他的文件中去，如果有的文件变量名重复了，容易造成问题。

## 3.2 标准库类型string

### 3.2.1 定义和初始化string对象

`string s(10, 'c');` s 的内容是 cccccccccc。

### 3.2.2 string对象上的操作

#### 读写string对象

在标准输入到string对象中时，会自动忽略掉开头的空白，读取直到遇到下一处空白为止。

如，输入的是`"   hello world!"`  那么输出只会是`"hello"`。

#### 使用getline读取一整行

有时候需要将空白也读出来，就可以用`getline(cin, line)`函数，此函数只会在遇到了换行符的时候调用`cin`输入到`line`中。

#### string::size_type 类型

`.size()`这个成员函数，返回的并不是int型，而是一个`size_type`型，该类型定义在`string`中，可以用`int`变量接，但是他是一个无符号整数，因此不要在一个表达式中混用有符号`int`和`.size()`函数，尤其是做比较时。

**这是因为，有可能size大小大于了一个int所能表示的范围。**

#### 字面值和string对象相加

**字符串字面值并不是string类型的对象** ，因此不能对两个字符串字面值直接使用‘+’号连接。

### 3.2.3 处理string对象中的字符

包含头文件`cctype`，里面有很多判断字符类型，转换大小写的函数。

#### 使用基于范围的for语句

`for(declaration : expression)`，其中，declaration是用于遍历用的需要定义的对象，expression则是待遍历的对象。例：

```c++
string s(10, 'c');
for(auto c : s) {
    cout << c << endl;
}
```

就可以输出字符串s的内容。

**值得注意的是，c并不像数组索引一样，确确实实的指向了内存中该字符所在的位置，而是将该字符的值赋给了c。**

所以，当要通过遍历的方式，修改s中的值，就需要将c定义为引用型,`for(auto &c: s)`，这样就将c绑定在了该字符上。

## 3.3 标准库类型vector

### 3.3.1 定义和初始化vector对象

在构造vector对象时，有许多的构造器，如`vector<int>  a(10, 1);`就表示vector容器a，是由10个1所构成。

列表初始化则是由花括号所构成，**值得注意的是，当花括号中的值，与vector中的类型不匹配时，编译器会尝试用默认值初始化vector对象，此时就不是列表初始化了**，如：

`vector<string> v8{10, "HI"};`,10并不是string类型，但是该语句不会报错，而是构造了一个存放着10个`"HI"`字符串的vector容器。

### 3.3.2 向vector对象中添加元素

**如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。**

范围for语句体内不应该改变其序列的大小。

#### 不能用下标的形式添加元素

可以用下标访问和修改，但是不能添加，要用`push_back();`。因为只能对已存在的元素进行下标操作。

## 3.4 迭代器介绍

#### 迭代器类型

* `iterator` 能够读写元素
* `const_iterator`只能够读元素，不能够写元素

如果vector或者string之类的容器中存放的是const常量，那么迭代器只能使用`const_iterator`。

#### 某些对vector对象的操作会使迭代器失效

**任何一种可能改变vector对象容量的操作，比如`push_back`，都会使该vector对象的迭代器失效。**

所以，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。

## 3.5 数组

### 3.5.1 定义和初始化内置数组

#### 字符数组的特殊性

在对字符数组进行列表初始化的时候，需要在末尾添加`'\0'`，来表示字符串的结尾。

或者是用`char c[] = "c++";`，双引号来进行初始化，就会自动添加`\0`。

#### 不允许拷贝和赋值

**不能用一个数组来对另一个数组进行拷贝，同理，不能用一个数组来对另一个数组进行初始化**

```c++
int a[] = {1, 2, 3};
int a2[] = a;  //错误
a2 = a;        //错误
```

#### 理解复杂的数组声明

```c++
int *ptrs[10]; //定义了一个存放着10个指向整数的指针的数组
int &refs[10]; //错误，引用不是一个对象，不能用数组
int (*Parray)[10] = &arr; //从数组名字从内往外读，Parray是一个指针，指向一个存放着10个整形变量的数组（即arr）
int (&arrRef)[10] = &arr; //arrRef是对名为arr的数组的引用。
```

### 3.5.3 指针和数组

很多用到数组名字的地方，编译器都会自动将其替换为一个指向数组首元素的指针。

#### 标准库函数begin和end

与容器中的begin和end功能一致，但是由于数组并不是容器，所以begin和end不是数组的成员函数，其调用方法是通过传参调用。

```c++
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int* beg = begin(ia);  //beg指向ia的首位
int* end = end(ia);   //end指向ia的末尾的下一位
```

**begin 和 end 两个函数定义在头文件iterator中。**

#### 下标和指针

内置的下标运算中的值，可以是负的，如以下代码：

```c++
int *p = ia[2];
int j = p[1];   //j也等于ia[3];
int k = p[-2];  //k也等于ia[0];
```

但是vector和string的下标运算不能是负的。

### 3.5.5 与旧代码的接口

因为有的c++程序不得不与用数组而没用容器，用字符数组而没用string的代码衔接，所以c++专门提供了一些功能。

#### 混用string对象和c风格的字符串

* 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。
* 在string对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个都是）；在string对象的赋值运算中允许使用以空字符结束的字符数组作为**右侧**的运算对象。

**但是，却不能用string对象来代替c风格的字符串，即不能用string对象直接给char[]赋值等。可以理解为，新的能兼容旧的，但是旧的却无法兼容新的。**

```c++
char *str = s; //错误，不能用string赋值
const char *str = s.c_str(); //正确，用string类的成员函数给str赋值
```

#### 使用数组初始化vector对象

不能用一个数组为另一个内置类型的数组赋初始值，也不能用vector对象初始化数组。但是可以用数组初始化vector。

```c++
int arr[] = {1, 2, 3, 4, 5};
vector<int> ivec(begin(arr), end(arr));
```

其中，`begin();`返回arr的头指针，`end();`返回arr的尾指针；也可以通过指针，截取一部分数组赋值给vector。

## 3.6 多维数组

#### 多维数组的下标引用

如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果就是该索引层的令一个数组，如：

```c++
int i[5][10];  //i是一个二维数组,5行10列
int (&j)[10] = i[2]; //将j绑定为i的第3行所存放的数组，元素为10个
```

#### 使用范围for语句处理多维数组

**要使用范围for语句处理多维数组，除了最内层的循环外，其他所有的循环的控制变量都应该是引用型。**

```c++
//正确
for (const auto &row : ia) { // row为引用型
    for (auto col : row)   //如果要修改值的话，这一层也得用引用型
        cout << col << endl;
}
//错误
for (auto row : ia) { //没有引用，此时row的值实际上是拷贝的ia里存放的数组指针，并不是数组的本体，所以接下来对row的遍历就是非法的；（原理和要修改值就得用引用一样）
    for(auto col : row)
        cout << col << endl;
}
```

#### 指针和多维数组

```c++
int *ip[4];      //这个定义是指ip中存放的是4个int型的指针
int (*ip)[4];    //这个定义是指ip指向一个存放了4个int变量的数组
```

举个例子，如果不用范围for循环来遍历一个二维数组的话，就需要用到`int (*ip)[4];`这种定义方法：

```c++
for(auto p = ia; p != ia + 3; p++) {
    //其中，p = ia是指，p指向了ia[3][4]这个二维数组的第一行，即ia[0]所在的位置，而ia[0]，又是存放的一个含有4个int的数组，即ia[0][0]的地址。
    //所以，p的值是ia[0]的地址，而*p就是ia[0]存放的东西，即ia[0][0]，也就是存放的数组的第一个元素。 因此，p++是遍历下一个数组。
    for(auto q = *p; q != *p + 4; q++) {
        //由上所述，定义一个指针q，存放*p即数组开头的地址，因此*q就是数组在该地址上的值。
        cout << *q << ' ' << endl;
    }
}
```

