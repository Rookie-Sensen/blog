---
title: 第6章|函数
date: 2023-06-02 21:40:15
tags: c++primer
---

# 6.函数

## 6.1 函数基础

### 6.1.1 局部对象

#### 局部静态对象

因为局部变量的声明周期只在函数调用时间内，但有时候希望在函数外部也能使用这个变量。 就可以把局部变量定义成`static`类型。

局部静态对象在程序的执行路径第一次经过对象定义语句时才初始化，直到程序终止时才被销毁，就算调用的函数执行完毕也不会有影响。

## 6.2 参数传递

### 6.2.3 const形参和实参

#### 尽量使用常量引用

在函数所需要传入的参数中，如果需要用到引用来防止函数拷贝实参节省空间，最好是使用常量引用而不是普通引用。

因为顶层const这种东西的存在，如果是普通的引用，那么就不能接受原来的参数是常量引用的传入进来，而且也容易误导使用者该参数是可以改变的。

因此，在传入参数需要用到引用，又在函数内不需要改变其值的时候，**尽量使用常量引用**如`const string &`。

### 6.2.4 数组形参

数组的特殊性质：

* 不允许拷贝数组
* 使用数组时会将其转化为指针

因此，在向函数中传入数组时，实际上是传入了数组的首元素的指针。

```c++
void print(const int*);
void print(const int[]);  //因为特性，也是传入的首指针
void print(const int[10]); //虽然他目的是想传10个大小的数组，但是由于只能传指针，所以传多大的都能接
```

上面3个函数声明，其实都是指同一个函数。

**也是由于这个特性，在函数中使用传入的数组时，要特别注意不要越界。**

有许多方法可以解决此问题：

* 使用标记指定数组长度：如c风格字符串的末尾是`'\0'`，就可以在遍历时判断是否到了末尾。
* 使用标准库规范：传入指向数组开头和末尾的两个指针。
* 显示的传递一个表示数组大小的形参，告知函数使用者传入的大小。
* 数组引用形参：`void print(int (&arr)[10])`,缺点是只能传入固定大小的数组。**16.1.1节会介绍解决方法**。

#### 传递多维数组

在c++中实际上是没有多维数组，而是用存放了数组的数组来表示多维数组的。

因此如果要传入多维数组，就需要将第2维及以后的信息传入函数中。

```c++
void print(int (*matrix)[10], int rowSize);
void print(int matrix[][10], int rowSize);
```

以上两种方式都可以传入多维数组。

**猜测`rowSize`应该是存放的第一个维度的大小。**

### 6.2.5 main：处理命令行选项

有时候也要通过命令行来对main函数进行传参，此时main函数就也要接受参数。

```c++
int main(int argc, char *argv[]){
	/*......*/
}
```

假定该main函数位于可执行文件prog内，则可输入：

`prog -d -o ofile data0`

`int argc`变量存放的是`argv[]`这个存放c字符串的数组中，存放了多少个字符串。

`char *argv[]`，也可以写成`char **argv`，都表示的是存放c风格字符串的数组。

以上面的命令行传入的参数为列，argc的值是5，argv的值如下：

```c++
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

**所以，当要使用`argv[]`中的值的时候，记得从`argv[1]`开始使用，因为`argv[0]`中存放的是文件名。**

### 6.2.6 含有可变形参的函数

有时候，我们无法预知到底会向函数里传入几个参数，有两种方法可以解决：

* 使用initializer_list标准库类型
* 编写可变参数模板的 函数（16.4节介绍）

#### initializer_list 形参

在函数的形参数量未知，但是未知的参数类型都相同时，就可以用此类型。

`initializer_list`与`vector`差不多，定义时必须说明列表中所含元素的类型:

```c++
initializer_list<string> ls;
initializer_list<int> li;
```

**与vector不同的是，initializer_list对象中的元素永远是常量值，无法改变对象里面的值：**

```c++
void error_msg(initializer_list<string> il) {
    /*...*/
}
```

上述函数就可以传入任意个string类型的变量。

#### 省略符形参

**省略符形参是便于c++程序访问某些特殊的c代码而设置的，因此只能用于c和c++通用的类型。大多数类类型的对象在传递给省略符形参时都无法正确拷贝。**

使用方法：

```c++
void foo(parm_list, ...);
void foo(...);
```

`...`代表任意类型的任意对象。

## 6.3 返回类型和return语句

### 6.3.2 有返回值函数

#### 值是如何被返回的

返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。

**也就是说，return返回的其实是返回值的拷贝。**

因此如果要返回真实的值，可以返回引用：

```c++
const string &shorterString(const string& s1, const string& s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}
```

在上述代码中，不论最后返回值是`s1`还是`s2`，最后返回值都是对应返回值的引用，而`s1`和`s2`本身也是作为引用型传入进来的，因此在此函数执行结束前后，都没有进行对字符串的拷贝。

#### 不要返回局部对象的引用和指针

很好理解，因为函数内部的局部对象和指针会在函数结束时释放掉，如果返回了其引用或者指针，该引用和指针就会指向一片已经被删除的区域，这显然是非常危险的。

#### 引用返回左值

可以对一个返回的是引用类型的函数直接进行对该对象相关的操作，如赋值等：

```c++
char &get_val(string &str, string::size_type ix) {
    return str[ix];
}
int main() {
    string s("a value");
    cout << s << endl;   //输出“a value”
    get_val(s, 0) = 'A';
    cout << s << endl;   //输出“A value”,上一个语句将'A'赋值给了第一个元素
}
```

除了引用返回类型，其他类型都是**右值**。

### 6.3.3 返回数组指针

因为数组不能够被拷贝，所以函数不能返回数组。虽然有点繁琐，但还是可以通过返回一个数组的指针或者引用的方式，来表示返回一个数组。

#### 声明一个返回数组指针的函数

首先回忆一下数组指针的定义方法

```c++
int arr[10];   //这是定义一个数组，存放10个int
int *p1[10];	//这也是定义一个数组，存放的是10个int*
int (*p2)[10] = &arr;  //这才是定义一个数组指针，指针存放10个int型的变量，p2指向arr。
```

和声明一样，如果想定义返回数组指针的函数，必须把数组的维度跟在函数的名字之后。形如：

`Type (*function(parameter_list))[dimension]`

例： `int (*func(int i)) [10];`

该函数返回的就是一个指向10个int型变量的数组的指针。

#### 使用类类型别名简化数组指针

```c++
typedef int arrT[10];
using arrT = int[10];  //用arrT来表示int[10]
arrT* func(int i);    //等同于 int (*fun(int i)) [10];
```

#### 使用尾置返回类型

任何函数的定义都能使用尾置返回类型，不过这种方法对复杂的函数定义更有效。

尾置返回类型跟在参数列表后面并以一个`->`符号开头。**为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放一个auto**。

`auto func(int i) -> int (*)[10];`

#### 使用decltype

如果我们知道函数返回的指针将指向哪一个数组，就可以使用`decltype`关键字来声明返回值类型。

如：

```c++
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6 ,8};
decltype(odd) *arrPtr(int i) {
    return (i % 2) ? &odd : &even;  //返回一个指向数组的指针，原理如int (*p)[10] = &arr;
}
```

`decltype(odd)`表示该类型是数组（和odd一样大），后面加`*`就表示返回的是指向这个类型的指针了。

## 6.4 重载函数

对于两个名字相同的函数，**其参数类型或者数量不同**，才是重载函数。

**注意：函数的返回值类型可以不同，但是不能只有函数的返回值类型不同。**

#### 重载和const形参

**顶层const不影响传入函数的对象。**因此一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来，也就无法成为重载函数。

```c++
Record lookup(Phone);
Record lookup(const Phone); //const是顶层的，这个重载是错误的。
```

这个const是顶层的，因为不论传入的参数是不是const，都能传进上面任意一个函数，编译器就无法知道到底要调用哪一个函数。

```c++
Record lookup(Phone *);
Record lookup(Phone * const);//这个const是顶层的，因此这个重载也是错误的。
```

这个const是顶层的，也是因为`Phone *const`只是表示这个指针不能再指向其他的值，和将要传入函数的参数的类型是没有关系的。因此编译器也无法通过参数的类型来分辨到底要调用哪一个函数。

```c++
Record lookup(Account&); //只有参数不是const的时候能调用
Record lookup(const Account&);//只有参数是const的时候能调用
Record lookup(Account *);//参数所指对象必须不是const
Record lookup(const Account*);
```

第一行，如果参数是const类型，由于非常量引用不能指向常量，因此他与第二行的函数是不同的。

第三行同理，因为不能将指向常量的指针赋值给非指向常量的指针，所以他与第三行的函数也是不同的。

也就实现了重载。

有一个问题是，当一个非常量或者非指向常量的指针传进了函数，以上4个函数都能满足对一个非常量或非指向常量的指针的传参，那么编译器会调用哪一个函数呢？

**答案是编译器会优先选用非常量的版本。**

#### const_cast和重载

在6.3.2的例子中，有这样一个函数：

```c++
const string &shorterString(const string& s1, const string& s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}
```

他传入了两个`const string&` 返回一个`const string&`。

但是此函数也能传入进非`const`的参数，但返回的时候依然是返回的`const`型，也就是说，一个非`const`的参数在经过函数的调用后变成了`const`的了，但是我们希望返回值也是非`const`型。

使用`const_cast`类就可以解决这类问题。

```c++
string &shorterString(string& s1, string& s2) {
    const string& r = shorterString(const_cast<const string&>(s1),const_cast<const string&> (s2));
   return const_cast<string&>(r);
}
```

上述函数利用`const_cast`类在重载函数的内部将普通引用转化为了常量引用去调用常量引用的函数，最后将常量引用函数求得的结果再一次通过`const_cast`类转化为了普通引用来返回。

### 6.4.1 重载与作用域

如果想重载的函数声明在了内层作用域内（尽管平时不会这样做），那么编译器会隐藏掉外层的函数，只会调用内层的函数，且当参数不满足内层函数对应的参数时（尽管满足外层函数的参数）也会报错。

```c++
string read();
void print(const string &);
void print(double);// 外层的重载print
void fooBar(int ival) {
    bool read = false;   //在内层作用域里，将read这个名字定义成了bool类型，编译不会报错，因为屏蔽了外层作用域里的read函数
    string s = read(); //报错，因为已经屏蔽了外层的函数，在内层作用域里，read是个bool变量
    void print(int);   //内层声明了一个print，因此屏蔽了外层的两个同名函数。这就不是重载了，就是一个函数。
    print("value:");  //错误，内层函数不支持传入string
    print(ival);  //正确
    print(3.14);  //正确，但是调用的是内层的print，会将3.14转化成整型的。
}
```

## 特殊用途语言特性

* 默认实参
* 内联函数
* `constexpr`函数

### 6.5.1 默认实参

有时候希望函数在普通情况下都有自己的默认值，如对一个窗口的属性设置，希望其长宽高或者背景都在用户不指定的情况下拥有默认设置，当然在用户指定的情况下也能进行输入。这个时候就可以对参数赋予默认值：

```c++
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
//在用户没有输入参数的时候，ht，wid，backgrnd都是用的参数列表中的这些值。
//用户输入后，就是用的用户输入的值
```

**值得注意的是，当参数中有一个设置了默认实参，则他后面（右边）的参数都要设置默认实参才行。**

#### 使用默认实参调用函数

默认实参负责填补函数调用缺少的尾部实参（靠右的位置）。

也就是说，**如果想要对`screen`函数的`backgrnd`传入自己指定的参数，就得把前面`ht`和`wid`的参数一并指定。**

```c++
window = screen(, , '?'); //错误，默认实参只能填补尾部的缺少项
window = screen('?'); //正确，但是调用的是screen('?' ,80 ,' ');
```

所以，合理设计参数顺序也是比较重要的。

#### 默认实参声明

在一个作用域里可以进行多次同一个函数的声明，但对默认参数的声明却只能有一个(但是可以进行补充)。

```c++
string screen(sz, sz, char = ''); //对char声明默认值
string screen(sz , sz , char = '*'); //错误，不能多次声明该默认参数
string screen(sz = 24 , sz = 80, char); //正确，补充了前两个的默认参数
```

#### 默认实参初始值

局部变量不能作为默认实参。除此之外，只要表达式类型能转化成形参所需的类型，该表达式就能作为默认实参：

```c++
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);//正确
```

并且如果在调用`screen`之前改变了以上全局变量的值，那么此函数的默认值也是会随着一起改变的。

### 6.5.2 内联函数和constexpr函数

对于一些函数，如`swap();`这种交换两个变量的值这种函数，是值得将其定义为一个函数的。因为在多个场景下可能都会用到这个函数，如果不用函数，就单纯的使用语句的话，以后如果有更改还得一行一行的修改，也不够方便。

**问题在于**，函数虽然能有许多方便之处，但是他相比于一条条语句，需要传参，需要调用函数栈等，会影响执行速率。

#### 内联函数可避免函数调用的开销

内联函数的意思就是，在函数编译过程中用对应的语句来逐一替换代码中对应的函数（原理就如同c语言中的`#define`，以及`const`一样）。

这样就既满足了函数的优点，也解决了函数的时间开销会大一点的问题（因为在编译阶段用对应的代码取代了函数）。

在函数的返回值类型前面加上关键字`inline`就可以将它声明成内联函数了。

```c++
inline const string& shorterString(const string &s1, const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}
```

**内联函数用于优化规模小、流程直接、频繁调用的函数。**

#### constexpr 函数 （mark）

`constexpr`函数是指能用于常量表达式的函数。在定义时要遵守一下规定：**函数的返回类型以及所有的形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。**

#### 把内联函数和constexpr函数放在头文件内

和其他函数不一样的是，内联和`constexpr`函数可以在程序中多次定义。但是多个定义必须完全一致，因此内联函数和`constexpr`函数的定义通常存放在头文件中。

### 6.5.3 调试帮助  （mark）

程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：`assert`、`NDEBUG`。

#### assert预处理宏

#### NDEBUG预处理变量

## 6.6 函数匹配

#### 含有多个形参的函数匹配

当实参的数量有两个或者多个时，就无法轻易的通过比较参数的匹配精度来决定该调用哪个函数了。

因为容易出现以下情况：

```c++
void f(int, int);
void f(double, double);
f(3, 3.14);
```

在实参传入`(3, 3.14)`的时候，第一个实参更匹配第一个函数，第二个实参更匹配第二个函数。

编译器最终将因为这个调用具有二义性而拒绝其请求：因为每个可行函数各自在一个实参上实现了更好的匹配，无法比较孰优孰劣。

**因此调用重载函数时尽量做到参数类型相匹配，避免出现类型转换。**

## 6.7 函数指针

函数的类型由他的返回值类型及其形参类型共同决定，与函数名无关。

```c++
bool lengthCompare(const string &, const string &);
```

该函数的类型是`bool (const string &, const string &)`。

要想声明这个函数的指针，只需要用指针替换函数名即可：

```c++
bool (*pf)(const string &, const string &);
```

#### 使用函数指针

**当我们把函数名当作值来使用时，函数自动转化成指针。如：**

```c++
pf = lengthCompare;    //将pf指向lengthCompaere这个函数
pf = &lengthCompare;   //同上，也就是说&可以省略
```

**还可以直接使用函数指针来调用函数，无需解引用：**

```c++
bool b1 = pf("hello", "goodbye");
bool b2 = (*pf)("hello", "goodbye");
bool b3 = lengthCompare("hello", "goodbye");
```

以上三种方式，全都表示同一个意思。

**不同函数指针之间不能互相转化，但是函数指针可以将其赋值为`0`或者`nullptr`，表示还没有指向任何函数。**

```c++
string::size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0;
pf = sumLength;   //已经确定pf是指向sumLength这个类型的函数
pf = cstringCompare; //错误，这个类型与pf所指的类型不符
pf = lengthCompare;  //正确（c类型字符串和string可以转化）,这两个函数是一个类型的
```

#### 重载函数的指针

编译器会通过指针类型决定调用哪个函数，指针类型必须与重载函数中的某一个精确匹配。

```c++
void ff(int*);
void ff(unsigned int);
//定义函数指针
void (*pf1)(unsigned int) = ff;  //指向的是第二个函数

void (*pf2)(int) = ff;   //错误，没有名为ff的函数，其参数是int型的
double (*pf3)(int*) = ff;   //错误，没有名为ff的函数，其返回值是double型的
```

#### 函数指针的形参

和数组一样，在函数的参数中，无法定义函数类型的形参，就用函数指针来代替。

**此时形参看起来像是一个函数，但是实际上是一个指针。**

```c++
void useBigger(const string &s1, const string &s2,
              bool pf(const string &, const string &));
//pf实际上是隐藏了(*pf)，以下是其显示的定义
void useBigger(const string &s1, const string &s2,
              bool (*pf)(const string &, const string &));
```

因为函数名会转化成对应函数的指针，所以可以直接把函数当实参传入。

`userBigger(s1, s2, lengthCompare);`直接传入`lengthCompare`会自动转化为函数指针。

与数组类似，直接使用函数指针的定义显得很繁琐。因此可以使用**类型别名和`decltype`来简化代码。**

#### 返回指向函数的指针

也和数组一样，不能返回一个函数类型，但是却可以返回一个指向函数的指针。但是编译器在返回值的时候，并不会自动的将返回类型当成对象的指针类型处理（编译器在return值的时候，仅仅是做了一个赋值操作）。

同数组指针的解决方案一样，可以使用类类型别名、`decltype`和`auto`，以及尾置返回类型的方式。
