---
title: 第4章|表达式
date: 2023-06-02 21:38:50
tags: c++primer
---

# 4.表达式

## 4.1 基础

### 4.1.1 基本概念

#### 运算对象转换

在表达式求值的时候，有时就算参与运算的对象类型不同也没关系，只要他们类型可以转化就可以，比如`int`可以转为`double`。

**小整数类型如（bool，char，short）会被提升为较大的整数类型，主要是int。**

#### 左值和右值

左值就是一个对象或者变量，代表着内存中的一个固定地址。

而右值要么是一个常量，要么是一个使用一次就被销毁的临时变量。

左值有时候可以充当右值，如

`i = i + 1;`,i即是左值，又是右值。

而右值是不能当左值的，因为右值在内存中没有存放。

### 4.1.3 求值顺序

在一个表达式中，运算优先级只决定了运算对象的组合方式，并不会决定运算对象按照什么顺序求值，如:

`int i = f1() + f2();`这个语句，可能是函数`f1()`先执行，也有可能是函数`f2()`先执行。

**标准输出运算符<<，也是如此，如：**

```c++
int i = 0;
cout << i << " " << ++i << endl;
//<<运算符，可能是先输出i，也有可能是已经执行了++i之后，再输出的i，即输出可能是 0 1,也有可能是1 1。
```

有4种运算符，是左侧为真之后，才执行右边的语句，这种求值方法被称为**短路求值**

* 与运算符`&&`
* 或运算符`||`
* 条件运算符`?:`
* 逗号运算符`,`

## 4.2 算术运算符

在c++新标准中，取余运算`m % n`，如果其结果不为0，其结果的符号和m的符号一致。

## 4.3 逻辑和关系运算符

逻辑运算符和关系运算符的返回值都是布尔类型，也都是右值。

#### 相等性测试与布尔字面值

要测试一个对象是否是真值，最好用以下方法

```c++
if(val) {/*...*/}
if(!val) {/*...*/}
//此时，val为真执行第一行，假执行第二行
```

尽量不要用一下方法

```c++
if(val == true) {/*...*/}
//此时如果val是int型，那么true会转变成int型的1，来与val进行比较，只有val == 1时，该表达式才为真
```

## 4.7 条件运算符

#### 在输出表达式中使用条件运算符

条件运算符的优先级非常低，所以在输出表达式中使用条件运算符的时候要对其添加括号，如：

```c++
cout << ((grade < 60) ? "fail" : "pass");
```

如果不加括号，就会先直接输出`grade < 60` 的结果，即1或0。

## 4.8 位运算符

位运算符会将参与运算的整型变量当作是一个32位的二进制数（有无符号取决于类型），然后根据对应的运算符，对其进行操作，比如左移、右移。

**编译器会把小整型提升成int型。**

**强烈建议只把位运算符作用于无符号类型。**

#### 移位运算符

左移运算符`<<`：在右侧插入值为0的二进制位，超出边界的位数丢弃。

右移运算符`>>`: 如果对象是无符号数，则插入0，如果是有符号的，保留符号位，插入0。

最后将移动后的值的拷贝作为求值结果。

例：

```c++
unsigned char bits = 0223;   // 10011011
bits << 8;     //10011011向左移动8位 ，即1001101100000000
bits >> 8;     //像右移动8位，即10011011
```

需要注意的是，右边移动的位数一定不能为负，且必须严格小于位数，否则将产生未定义的行为。

#### 位求反运算符

位求反运算符`~`：对运算对象逐位求反。如：

```c++
unsigned char bits = 0227; //10010111
~bits;     //先用0补全高位后取反，11111111 11111111 11111111 01101000
```

#### 位与、位或、位异或运算符

与`&`,或`|`,异或`^`运算符在两个运算对象上逐位执行相应的操作。

## 4.9 sizeof运算符

sizeof运算符返回一条表达式或者一个类型名字所占的字节数。

```c++
sizeof (type);  //返回type这个类型的大小
sizeof expr;  //返回expr这个表达式返回值的大小
```

**值得注意的是，sizeof并不会运算expr，而是只返回他结果的类型的大小。
